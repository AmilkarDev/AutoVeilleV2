using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace Outils
{
    /// <summary>
    /// This class implements a simple form of templating.
    /// </summary>
    /// <remarks>
    /// Templates may be of anything.  They are source data that is generated by an application during the course of its operations.
    /// A template is held into a file.  This file may be embedded as a resource or provided in an external directory integrated
    /// with the application.  In this case, an appSetting must be set to designate the templates location (the same as with the string localizer).
    /// <para>
    /// Within a template, parameters may be substituted.  A substitution os of the form:
    ///    {$name:default$}
    /// where 'name' is the name of the variable, which may optionally be followed with a default value.  The default value is used when there is
    /// no value provided with the parameter. The name must be a valid C# identifier.
    /// </para>
    /// <para>
    /// Templates, once loaded, are cached in memory.  To prevent a specific template from being cached, you must start it with the reserved
    /// keyword {$nocache$}.  Templates may include other templates.  When the id of a keyword starts with '*', it is interpreted as a template
    /// inclusion.  When loading a template, the engine starts be inserting all templates recursively before proceeding with variable substitution.
    /// </para>
    /// <para>
    /// Refer to the header of the LoadAndFill() method for a description of how to invoke a template.
    /// </para>
    /// Note that loading templates on each instantiation is very inefficient.  We should keep a static cache for each extension and load it only once.
    /// The process should be protected with a lock.
    /// </remarks>
    public class StringTemplate
    {
        #region Private Class: CacheEntry

        /// <summary>
        /// Keeps a cache entry.
        /// </summary>
        private class CacheEntry
        {
            /// <summary>
            /// When it is a resource, this is the assembly where the resource resides.
            /// </summary>
            public Assembly Assembly;

            /// <summary>
            /// The template name.
            /// </summary>
            public String Name;

            /// <summary>
            /// The path by which we can load the template.
            /// </summary>
            public String Path;

            /// <summary>
            /// The text of the template when it has already been loaded.
            /// </summary>
            public String Text;
        }

        #endregion

        #region Public Properties/Fields

        #endregion

        #region Private Properties/Fields

        /// <summary>
        /// Template cache.
        /// </summary>
        private readonly Dictionary<String, CacheEntry> _templates = new Dictionary<String, CacheEntry>();

        #endregion

        #region Constructors

        /// <summary>
        /// The default constructor.
        /// </summary>
        public StringTemplate()
        {
            IntegrateTemplates(Assembly.GetCallingAssembly(), ".template");
            IntegrateTemplates(ConfigurationManager.AppSettings["TemplatesPath"], ".template");
        }

        /// <summary>
        /// The default constructor loads templates first from the resources and then from the appSetting.
        /// </summary>
        /// <param name="pExtension"></param>
        public StringTemplate(String pExtension)
        {
            if (pExtension[0] != '.')
                pExtension = "." + pExtension;
            IntegrateTemplates(Assembly.GetCallingAssembly(), pExtension);
            IntegrateTemplates(ConfigurationManager.AppSettings["TemplatesPath"], pExtension);
        }

        #endregion

        /// <summary>
        /// Load the cache from embedded resources.
        /// </summary>
        /// <param name="pExtension"></param>
        /// <remarks>
        /// The assembly may easily be obtained from a type of the assembly.
        /// </remarks>
        private void IntegrateTemplates(Assembly pAssembly, String pExtension)
        {
            pAssembly.GetManifestResourceNames().Where(rn => rn.ToLower().EndsWith(pExtension))
                .Select(rn => new CacheEntry { Name = GetName(rn), Assembly = pAssembly, Path = rn })
                .ToList().ForEach(ce => IntegrateTemplate(ce));
        }

        /// <summary>
        /// Load templates from the specified path.
        /// </summary>
        /// <param name="pPath">The path to the template files.  We do not scan recusively.</param>
        /// <param name="pExtension"></param>
        private void IntegrateTemplates(String pPath, String pExtension)
        {
            if (pPath == null)
                return;
            foreach (String path in pPath.Split(';'))
                if (Directory.Exists(path))
                    Directory.GetFiles(path, "*" + pExtension)
                        .Select(rn => new CacheEntry { Name = GetName(rn), Assembly = null, Path = rn })
                        .ToList().ForEach(ce => IntegrateTemplate(ce));
        }

        /// <summary>
        /// Loads a template and fills it with the provided variables.
        /// </summary>
        /// <param name="pName">The template name.</param>
        /// <param name="pOptions">Options affecting the behavior of the operation.</param>
        /// <param name="pVariables">Variables to be substituted in the template.</param>
        /// <returns>The template text with all variables substituted.</returns>
        /// <remarks>
        /// The template is loaded and variables are substituted.  If a keyword has no corresponding
        /// variable, its default value is used.  If there is no default value, an empty string is set.
        /// </remarks>
        public String LoadAndFill(String pName, StringTemplateOptions pOptions, Object pVariables)
        {
            //--- Load the requested model.

            String templateModel = LoadTemplate(pName);
            if (templateModel == null)
                return null;

            //--- Extract variables.

            Dictionary<String, Object> variables = Utils.ToDictionary(pVariables);

            //--- We must then honor the inclusions.  An inclusion is indicated by a variable whose name starts with a '*'.
            //    The expession matched is: {$*name:defaultName$} where 'name' and 'defaultName' must be valid C# identifiers.

            var result = new StringBuilder(templateModel);
            var includeEx = new Regex(@"\{\$\*([a-zA-Z_]\w*)(:[a-zA-Z_]\w*)?\$\}");
            MatchCollection matches = includeEx.Matches(templateModel);
            var processedMatches = new List<String>();
            foreach (Match match in matches)
            {
                string currentMatch = match.ToString();
                if (!processedMatches.Contains(currentMatch))
                {
                    processedMatches.Add(currentMatch);
                    string targetValue = variables.GetValue(match.Groups[1].Value,
                                                            String.IsNullOrEmpty(match.Groups[2].Value)
                                                                ? null
                                                                : match.Groups[2].Value.Substring(1));
                    if (String.IsNullOrEmpty(targetValue))
                        result.Replace(match.Groups[0].Value, String.Empty);
                    else
                        result.Replace(match.Groups[0].Value,
                                       LoadAndFill(targetValue, pOptions | StringTemplateOptions.InclusionsOnly,
                                                   variables) ?? String.Empty);
                }
            }

            //--- If only inclusions were requested, stop processing here.

            if ((pOptions & StringTemplateOptions.InclusionsOnly) == StringTemplateOptions.InclusionsOnly)
                return result.ToString();

            //--- We now have all inclusions taken care of.  Let us proceed with the substitutions.

            var variableEx = new Regex(@"\{\$([a-zA-Z_]\w*)(.*?)\$\}");
            matches = variableEx.Matches(result.ToString());
            processedMatches.Clear();
            foreach (Match match in matches)
            {
                string currentMatch = match.ToString();
                if (processedMatches.Contains(currentMatch)) continue;

                processedMatches.Add(currentMatch);
                string defaultValue = match.Groups[2].Length <= 1 ? null : match.Groups[2].Value.Substring(1);
                string targetValue = variables.GetValueAsString(match.Groups[1].Value, defaultValue);
                result.Replace(match.Groups[0].Value, String.IsNullOrEmpty(targetValue) ? String.Empty : targetValue);
            }

            //--- If no blank flushing requested, we are done.

            if ((pOptions & StringTemplateOptions.TrimBlanks) != StringTemplateOptions.TrimBlanks)
                return result.ToString();

            //--- If blanks are to be flushed.

            return new Regex(@"[ \t]*(\r\n|\r|\n)[ \t]*").Replace(result.ToString(), "$1");
        }

        /// <summary>
        /// If a template is not already registered under this name, add the specified template.
        /// </summary>
        /// <param name="pEntry"></param>
        private void IntegrateTemplate(CacheEntry pEntry)
        {
            if (!_templates.ContainsKey(pEntry.Name))
                _templates.Add(pEntry.Name, pEntry);
        }

        /// <summary>
        /// The name of the template is the next to last entry.
        /// </summary>
        /// <param name="pPath"></param>
        /// <returns></returns>
        private static String GetName(String pPath)
        {
            string[] components = pPath.Split('.', '\\');
            return components[components.Length - 2].ToLower();
        }

        /// <summary>
        /// Loads a template and returns its raw text.
        /// </summary>
        /// <param name="pName">Name of the template to load.</param>
        /// <returns>The raw template text.  If a leading {$nocache$} keyword was found, it is removed.</returns>
        private String LoadTemplate(String pName)
        {
            //--- If we cannot locate the entry, the template is nknown.

            CacheEntry cacheEntry;
            if (!_templates.TryGetValue(pName.ToLower(), out cacheEntry))
                return null;

            //--- If it resides in the cache, return it.

            if (cacheEntry.Text != null)
                return cacheEntry.Text;

            //--- Load from embedded resources.

            String templateText = null;
            if (cacheEntry.Assembly != null)
            {
                using (Stream stream = cacheEntry.Assembly.GetManifestResourceStream(cacheEntry.Path))
                using (var reader = new StreamReader(stream))
                    templateText = reader.ReadToEnd();
            }

                //--- Load from file.

            else
                using (var reader = new StreamReader(cacheEntry.Path))
                    templateText = reader.ReadToEnd();

            //--- Check for the nocache option.

            const String noCache = "{$nocache$}";
            if (templateText.Substring(0, noCache.Length).ToLower() == noCache)
            {
                int lengthToRemove = noCache.Length;
                if (templateText[noCache.Length] == '\r' && templateText[noCache.Length + 1] == '\n')
                    lengthToRemove += 2;
                templateText = templateText.Substring(lengthToRemove);
            }
            else
                cacheEntry.Text = templateText;

            return templateText;
        }
    }
}